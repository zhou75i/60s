<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>60s读懂世界</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #fff; display: flex; justify-content: center; align-items: flex-start; padding: 20px; }
        #img-result { max-width: 100%; height: auto; }
        canvas { display: none; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <img id="img-result" alt="60s读懂世界" />

    <script>
        let DATA = window.DATA || {};
        const CONFIG = {
            // 远程图片链接（增加备用链接）
            bannerUrl: 'https://cdn.jsdmirror.com/gh/zhou75i/60s@main/img/1.png',
            footerUrl: 'https://cdn.jsdmirror.com/gh/zhou75i/60s@main/img/2.png',
            fontUrl: 'https://cdn.bootcdn.net/ajax/libs/font-awesome/6.4.0/fonts/fa-solid-900.woff2',
            dateY: 70, // 校准日期Y轴（适配120高度的banner）
            newsStartY: 140, // 校准新闻起始Y轴
            font: {
                date: { size: 32, color: '#ffffff', weight: 'bold' },
                news: { size: 28, color: '#333333', weight: 'normal' },
                weiyu: { size: 26, color: '#666666', weight: 'normal' },
                lineHeight: 1.8
            },
            padding: { left: 50, right: 50 },
            clipExtra: 20,
            bannerHeight: 120, // 固定banner高度（避免图片加载失败后高度不一致）
            footerHeight: 60   // 固定footer高度
        };

        // 辅助函数：加载图片（带容错和超时）
        function loadImage(url, timeout = 10000) {
            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                const timer = setTimeout(() => {
                    console.warn(`图片加载超时/失败：${url}，使用纯色替代`);
                    resolve(null);
                }, timeout);

                img.onload = () => {
                    clearTimeout(timer);
                    resolve(img);
                };
                img.onerror = () => {
                    clearTimeout(timer);
                    console.warn(`图片加载失败：${url}，使用纯色替代`);
                    resolve(null);
                };
                img.src = url;
            });
        }

        // 生成图片核心逻辑
        async function generate() {
            try {
                console.log('开始绘制，DATA数据：', JSON.stringify(DATA).substring(0, 100));
                
                // 数据容错
                if (!DATA || typeof DATA !== 'object') throw new Error('注入的数据为空或格式异常');
                DATA.news = Array.isArray(DATA.news) ? DATA.news : [];
                DATA.tip = DATA.tip || '暂无微语';

                // 1. 初始化Canvas（强制不透明背景）
                const canvas = document.getElementById('canvas');
                const ctx = canvas.getContext('2d');
                const canvasWidth = 800;
                canvas.width = canvasWidth;
                canvas.height = 2000; // 初始足够高的画布

                // 强制填充背景色（关键：先填充整个画布，确保无透明区域）
                ctx.fillStyle = '#f5f5f5';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                console.log('已填充画布背景，尺寸：', canvas.width + 'x' + canvas.height);

                // 2. 绘制Banner（优先图片，失败则纯色）
                const bannerImg = await loadImage(CONFIG.bannerUrl);
                if (bannerImg) {
                    // 绘制Banner图片（铺满宽度，高度固定为CONFIG.bannerHeight）
                    ctx.drawImage(bannerImg, 0, 0, canvasWidth, CONFIG.bannerHeight);
                    console.log('绘制Banner图片完成');
                } else {
                    // 纯色Banner（深色背景，确保日期文字可见）
                    ctx.fillStyle = '#2c3e50';
                    ctx.fillRect(0, 0, canvasWidth, CONFIG.bannerHeight);
                    console.log('绘制纯色Banner完成');
                }

                // 3. 绘制日期（确保在Banner内）
                const formatDateStr = getFormatDate(DATA.date, DATA.lunar_date);
                ctx.fillStyle = CONFIG.font.date.color;
                ctx.font = `${CONFIG.font.date.weight} ${CONFIG.font.date.size}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.fillText(formatDateStr, canvasWidth / 2, CONFIG.dateY);
                console.log('绘制日期：', formatDateStr, '坐标：', canvasWidth/2, CONFIG.dateY);

                // 4. 绘制新闻列表
                ctx.fillStyle = CONFIG.font.news.color;
                ctx.font = `${CONFIG.font.news.weight} ${CONFIG.font.news.size}px sans-serif`;
                ctx.textAlign = 'left';
                let currentY = CONFIG.newsStartY;
                const lineHeightNews = CONFIG.font.news.size * CONFIG.font.lineHeight;
                const maxWidth = canvasWidth - CONFIG.padding.left - CONFIG.padding.right;

                DATA.news.forEach((news, index) => {
                    const newsText = news || `暂无新闻${index + 1}`;
                    const text = `${index + 1}、${newsText}`;
                    const lines = wrapText(ctx, text, maxWidth);
                    
                    lines.forEach(line => {
                        ctx.fillText(line, CONFIG.padding.left, currentY);
                        console.log(`绘制新闻${index+1}：`, line, '坐标：', CONFIG.padding.left, currentY);
                        currentY += lineHeightNews;
                    });
                });

                // 5. 绘制微语
                ctx.fillStyle = CONFIG.font.weiyu.color;
                ctx.font = `${CONFIG.font.weiyu.weight} ${CONFIG.font.weiyu.size}px sans-serif`;
                const weiyuText = `【微语】${DATA.tip}`;
                const weiyuLines = wrapText(ctx, weiyuText, maxWidth);
                const lineHeightWeiyu = CONFIG.font.weiyu.size * CONFIG.font.lineHeight;
                
                weiyuLines.forEach(line => {
                    ctx.fillText(line, CONFIG.padding.left, currentY);
                    console.log('绘制微语：', line, '坐标：', CONFIG.padding.left, currentY);
                    currentY += lineHeightWeiyu;
                });

                // 6. 绘制Footer（优先图片，失败则纯色）
                const footerTop = currentY + 20;
                const footerImg = await loadImage(CONFIG.footerUrl);
                if (footerImg) {
                    ctx.drawImage(footerImg, 0, footerTop, canvasWidth, CONFIG.footerHeight);
                    console.log('绘制Footer图片完成，坐标：', 0, footerTop);
                } else {
                    ctx.fillStyle = '#2c3e50';
                    ctx.fillRect(0, footerTop, canvasWidth, CONFIG.footerHeight);
                    console.log('绘制纯色Footer完成，坐标：', 0, footerTop);
                }

                // 7. 裁剪画布到实际内容（保留足够底部空间，避免内容被截断）
                const finalHeight = footerTop + CONFIG.footerHeight + 20;
                canvas.height = finalHeight;
                console.log('裁剪后画布尺寸：', canvas.width + 'x' + canvas.height);

                // 8. 生成Base64（强制PNG不透明）
                window.IMAGE_BASE64 = canvas.toDataURL('image/png', 1.0);
                console.log('图片生成成功，Base64长度：', window.IMAGE_BASE64.length);

            } catch (err) {
                console.error('图片生成失败：', err);
                window.IMAGE_ERROR = err.message;
            }
        }

        // 辅助函数：格式化日期
        function getFormatDate(rawDate, lunarDate) {
            const dateStr = rawDate || new Date().toISOString().split('T')[0];
            const [year, month, day] = dateStr.split('-').map(Number);
            const formattedYear = year || new Date().getFullYear();
            const formattedMonth = month ? month.toString().padStart(2, '0') : (new Date().getMonth() + 1).toString().padStart(2, '0');
            const formattedDay = day ? day.toString().padStart(2, '0') : new Date().getDate().toString().padStart(2, '0');
            
            const weekDays = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];
            const weekDay = weekDays[new Date(dateStr).getDay()];
            
            return `${formattedYear}年${formattedMonth}月${formattedDay}日 ${lunarDate || ''} ${weekDay}`.replace(/\s+/g, ' ').trim();
        }

        // 辅助函数：文本换行
        function wrapText(ctx, text, maxWidth) {
            const lines = [];
            let currentLine = '';
            const words = text.split('');
            for (let word of words) {
                const testLine = currentLine + word;
                const metrics = ctx.measureText(testLine);
                if (metrics.width > maxWidth && currentLine) {
                    lines.push(currentLine);
                    currentLine = word;
                } else {
                    currentLine = testLine;
                }
            }
            if (currentLine) lines.push(currentLine);
            return lines;
        }
    </script>
</body>
</html>
