<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>60s读懂世界</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #fff; display: flex; justify-content: center; align-items: flex-start; min-height: 100vh; padding: 20px; }
        #img-result { max-width: 100%; height: auto; }
        canvas { display: none; }
    </style>
    <!-- 强制加载思源黑体（避免字体缺失） -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <canvas id="canvas"></canvas>
    <img id="img-result" alt="60s读懂世界" />

    <script>
        let DATA = window.DATA || {};
        const CONFIG = {
            bannerUrl: 'https://raw.githubusercontent.com/zhou75i/60s/main/img/1.png',
            footerUrl: 'https://raw.githubusercontent.com/zhou75i/60s/main/img/2.png',
            // 关键调整：新闻起始Y坐标（远离Banner，确保视觉可见）
            dateY: 120,       // 日期上移，适配Banner视觉中心
            newsStartY: 400,  // 新闻起始Y下调，确保在Banner下方完全可见
            font: {
                date: { size: 36, family: 'Noto Sans SC', color: '#ffffff', weight: '700' },
                news: { size: 24, family: 'Noto Sans SC', color: '#333333', weight: '400' }, // 缩小字号+黑体确保可见
                weiyu: { size: 22, family: 'Noto Sans SC', color: '#666666', weight: '400' },
                lineHeight: 2.0 // 增大行高，避免文字重叠
            },
            padding: { left: 60, right: 60 }, // 增大左右内边距，适配换行
            clipExtra: 50,                     // 增大裁剪余量，避免内容被裁
            bannerHeight: 364,                 // 固定Banner高度
            footerHeight: 100                  // 固定Footer高度
        };

        /**
         * 加载图片（带兜底）
         */
        function loadImage(url) {
            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => resolve(img);
                img.onerror = () => {
                    // 图片加载失败，创建纯色占位Banner/Footer
                    const placeholder = new Image();
                    placeholder.width = 1000;
                    placeholder.height = url.includes('1.png') ? CONFIG.bannerHeight : CONFIG.footerHeight;
                    resolve(placeholder);
                };
                img.src = url;
            });
        }

        /**
         * 格式化日期
         */
        function formatDate(rawDate, lunarDate) {
            if (!rawDate) rawDate = new Date().toISOString().split('T')[0];
            const [year, month, day] = rawDate.split('-');
            const weekDays = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];
            const weekDay = weekDays[new Date(rawDate).getDay()];
            return `${year}年${month}月${day}日 农历·${lunarDate || '未知'} / ${weekDay}`;
        }

        /**
         * 文本换行（适配长文本，强制拆分）
         */
        function wrapText(ctx, text, x, y, maxWidth, fontConfig) {
            ctx.font = `${fontConfig.weight} ${fontConfig.size}px ${fontConfig.family}`;
            ctx.fillStyle = fontConfig.color;
            ctx.textBaseline = 'top'; // 固定基线，避免偏移

            const lines = [];
            let currentLine = '';
            let currentY = y;
            const lineHeight = fontConfig.size * CONFIG.lineHeight;

            // 逐字拆分，确保超长文本也能换行
            for (let char of text) {
                const testLine = currentLine + char;
                if (ctx.measureText(testLine).width > maxWidth && currentLine) {
                    lines.push({ text: currentLine, y: currentY });
                    currentLine = char;
                    currentY += lineHeight;
                } else {
                    currentLine = testLine;
                }
            }
            if (currentLine) lines.push({ text: currentLine, y: currentY });
            return lines;
        }

        /**
         * 核心绘制逻辑（可视化优先）
         */
        async function generate() {
            try {
                // 最终数据兜底
                DATA = window.DATA || {};
                DATA.date = DATA.date || new Date().toISOString().split('T')[0];
                DATA.lunar_date = DATA.lunar_date || '未知';
                DATA.news = Array.isArray(DATA.news) ? DATA.news.filter(n => n && n.trim()) : [];
                DATA.tip = DATA.tip || '暂无微语';

                console.log('绘制数据确认：', {
                    date: DATA.date,
                    newsCount: DATA.news.length,
                    weiyu: DATA.tip
                });

                // 1. 加载图片资源
                const [bannerImg, footerImg] = await Promise.all([
                    loadImage(CONFIG.bannerUrl),
                    loadImage(CONFIG.footerUrl)
                ]);
                const canvasWidth = bannerImg.width || 1000;

                // 2. 初始化画布（固定宽度，足够高的高度）
                const canvas = document.getElementById('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = canvasWidth;
                canvas.height = 3000; // 足够高，避免内容溢出

                // 3. 绘制白色背景（强制不透明）
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvasWidth, canvas.height);

                // 4. 绘制Banner（优先图片，失败则纯色）
                ctx.drawImage(bannerImg, 0, 0, canvasWidth, CONFIG.bannerHeight);
                // Banner底部绘制分割线（视觉区分）
                ctx.strokeStyle = '#eeeeee';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(CONFIG.padding.left, CONFIG.bannerHeight);
                ctx.lineTo(canvasWidth - CONFIG.padding.right, CONFIG.bannerHeight);
                ctx.stroke();

                // 5. 绘制日期（居中，白色文字+阴影确保可见）
                const dateText = formatDate(DATA.date, DATA.lunar_date);
                ctx.font = `${CONFIG.font.date.weight} ${CONFIG.font.date.size}px ${CONFIG.font.date.family}`;
                ctx.fillStyle = CONFIG.font.date.color;
                ctx.textAlign = 'center';
                ctx.shadowColor = 'rgba(0,0,0,0.5)'; // 文字阴影，确保在Banner上可见
                ctx.shadowBlur = 3;
                ctx.fillText(dateText, canvasWidth / 2, CONFIG.dateY);
                ctx.shadowBlur = 0; // 关闭阴影

                // 6. 绘制新闻列表（核心：确保可见）
                ctx.textAlign = 'left';
                ctx.shadowBlur = 0;
                const newsMaxWidth = canvasWidth - CONFIG.padding.left - CONFIG.padding.right;
                let currentY = CONFIG.newsStartY;

                DATA.news.forEach((news, index) => {
                    const newsText = `${index + 1}、${news.trim()}`;
                    const lines = wrapText(ctx, newsText, CONFIG.padding.left, currentY, newsMaxWidth, CONFIG.font.news);
                    
                    // 逐行绘制新闻
                    lines.forEach(line => {
                        ctx.fillText(line.text, CONFIG.padding.left, line.y);
                        currentY = line.y + CONFIG.font.news.size * CONFIG.lineHeight;
                    });
                    // 每条新闻后增加间距
                    currentY += 10;
                });

                // 7. 绘制微语（新闻下方，视觉区分）
                currentY += 20; // 微语与新闻间距
                const weiyuText = `【微语】${DATA.tip}`;
                const weiyuLines = wrapText(ctx, weiyuText, CONFIG.padding.left, currentY, newsMaxWidth, CONFIG.font.weiyu);
                weiyuLines.forEach(line => {
                    ctx.fillText(line.text, CONFIG.padding.left, line.y);
                    currentY = line.y + CONFIG.font.weiyu.size * CONFIG.lineHeight;
                });

                // 8. 绘制Footer（微语下方）
                currentY += 30; // Footer与微语间距
                ctx.drawImage(footerImg, 0, currentY, canvasWidth, CONFIG.footerHeight);

                // 9. 裁剪画布（仅裁剪到实际内容高度，保留所有绘制内容）
                const finalHeight = currentY + CONFIG.footerHeight + CONFIG.clipExtra;
                // 创建最终画布，避免裁剪原画布
                const finalCanvas = document.createElement('canvas');
                finalCanvas.width = canvasWidth;
                finalCanvas.height = finalHeight;
                const finalCtx = finalCanvas.getContext('2d');
                
                // 复制原画布内容到最终画布
                finalCtx.fillStyle = '#ffffff';
                finalCtx.fillRect(0, 0, canvasWidth, finalHeight);
                finalCtx.drawImage(canvas, 0, 0, canvasWidth, finalHeight, 0, 0, canvasWidth, finalHeight);

                // 10. 生成Base64（强制PNG，高质量）
                window.IMAGE_BASE64 = finalCanvas.toDataURL('image/png', 1.0);
                console.log('图片生成完成，最终尺寸：', canvasWidth + 'x' + finalHeight);
                console.log('Base64长度：', window.IMAGE_BASE64.length);

            } catch (err) {
                console.error('绘制失败：', err);
                window.IMAGE_ERROR = err.message;
            }
        }
    </script>
</body>
</html>
