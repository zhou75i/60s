<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>60s读懂世界</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #fff; display: flex; justify-content: center; align-items: flex-start; min-height: 100vh; padding: 20px; }
        #img-result { max-width: 100%; height: auto; }
        canvas { display: none; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <img id="img-result" alt="60s读懂世界" />

    <script>
        let DATA = window.DATA || {};
        let customFont = null;
        const CONFIG = {
            bannerUrl: 'https://cdn.jsdmirror.com/gh/zhou75i/60s@main/img/1.png',
            footerUrl: 'https://cdn.jsdmirror.com/gh/zhou75i/60s@main/img/2.png',
            fontUrl: 'https://cdn.jsdmirror.com/gh/zhou75i/60s@main/fonts/DouyinSansBold.otf',
            dateY: 290,
            newsStartY: 430,
            font: {
                date: { size: 32, family: 'DouyinSansBold', color: '#ffffff', weight: 'normal' },
                news: { size: 28, family: 'DouyinSansBold', color: '#333333' },
                weiyu: { size: 26, family: 'DouyinSansBold', color: '#666666' },
                lineHeight: 1.8
            },
            padding: { left: 50, right: 50 },
            clipExtra: 20
        };

        /**
         * 加载自定义字体（强化等待生效）
         */
        async function loadCustomFont() {
            try {
                const font = new FontFace('DouyinSansBold', `url(${CONFIG.fontUrl})`);
                await font.load();
                document.fonts.add(font);
                customFont = font;
                // 强制等待字体生效
                await document.fonts.ready;
                console.log('自定义字体加载并生效');
            } catch (err) {
                console.warn('自定义字体加载失败，降级为思源黑体：', err);
                const link = document.createElement('link');
                link.href = 'https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@700;400&display=swap';
                link.rel = 'stylesheet';
                document.head.appendChild(link);
                // 等待样式加载完成
                await new Promise(resolve => {
                    link.onload = resolve;
                    setTimeout(resolve, 3000); // 超时兜底
                });
                CONFIG.font.date.family = 'Noto Sans SC';
                CONFIG.font.news.family = 'Noto Sans SC';
                CONFIG.font.weiyu.family = 'Noto Sans SC';
            }
        }

        /**
         * 格式化日期
         */
        function formatDate(rawDate, lunarDate) {
            const [year, month, day] = rawDate.split('-');
            const weekDays = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];
            const weekDay = weekDays[new Date(rawDate).getDay()];
            const solarDate = `${year}年${month}月${day}日`;
            return `${solarDate} 农历 · ${lunarDate} / ${weekDay}`;
        }

        /**
         * 文本换行处理（强化参数校验）
         */
        function wrapText(ctx, text, x, y, maxWidth, fontConfig, isCenter = false) {
            // 强制设置字体和颜色，避免状态污染
            ctx.font = `${fontConfig.weight || 'normal'} ${fontConfig.size}px ${fontConfig.family}`;
            ctx.fillStyle = fontConfig.color;
            ctx.textBaseline = 'top';
            ctx.textAlign = isCenter ? 'center' : 'left';

            let lines = [];
            let currentLine = '';
            let currentY = y;
            const lineH = fontConfig.size * CONFIG.font.lineHeight;

            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const testLine = currentLine + char;
                if (ctx.measureText(testLine).width > maxWidth && currentLine) {
                    lines.push({ text: currentLine, y: currentY });
                    currentLine = char;
                    currentY += lineH;
                } else {
                    currentLine = testLine;
                }
            }
            if (currentLine) {
                lines.push({ text: currentLine, y: currentY });
            }
            return lines;
        }

        /**
         * 绘制白色背景
         */
        function drawWhiteBackground(ctx, width, height) {
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, width, height);
        }

        /**
         * 加载图片
         */
        function loadImage(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => resolve(img);
                img.onerror = () => reject(new Error(`图片加载失败：${url}`));
                img.src = url;
            });
        }

        /**
         * 核心生成逻辑（移除兜底+修复绘制错误）
         */
        async function generate() {
            try {
                // 1. 加载字体（必须等待完成）
                await loadCustomFont();

                // 2. 加载Banner和Footer图片
                const [bannerImg, footerImg] = await Promise.all([
                    loadImage(CONFIG.bannerUrl),
                    loadImage(CONFIG.footerUrl)
                ]);
                const canvasW = bannerImg.width;
                console.log('图片资源加载完成，Banner尺寸：', canvasW + 'x' + bannerImg.height);

                // 3. 初始化主画布
                const canvas = document.getElementById('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = canvasW;
                canvas.height = 5000;

                // 4. 绘制白色背景
                drawWhiteBackground(ctx, canvasW, canvas.height);

                // 5. 绘制Banner图片
                ctx.drawImage(bannerImg, 0, 0);

                // 6. 绘制日期（居中）
                const formatDateStr = formatDate(DATA.date, DATA.lunar_date);
                const dateMaxW = canvasW - CONFIG.padding.left - CONFIG.padding.right;
                const dateLines = wrapText(ctx, formatDateStr, 0, CONFIG.dateY, dateMaxW, CONFIG.font.date, true);
                // 居中绘制：x为画布中点
                dateLines.forEach(line => {
                    ctx.fillText(line.text, canvasW / 2, line.y);
                });
                console.log('日期绘制完成：', formatDateStr);

                // 7. 绘制新闻列表（移除兜底）
                let currentY = CONFIG.newsStartY;
                const newsMaxW = canvasW - CONFIG.padding.left - CONFIG.padding.right;

                DATA.news.forEach((news, index) => {
                    const text = `${index + 1}、${news.trim()}`;
                    // 每次绘制前重置字体和颜色，避免状态污染
                    ctx.font = `${CONFIG.font.news.weight || 'normal'} ${CONFIG.font.news.size}px ${CONFIG.font.news.family}`;
                    ctx.fillStyle = CONFIG.font.news.color;
                    ctx.textAlign = 'left';
                    
                    const newsLines = wrapText(ctx, text, CONFIG.padding.left, currentY, newsMaxW, CONFIG.font.news);
                    newsLines.forEach(line => {
                        ctx.fillText(line.text, line.x, line.y);
                    });
                    currentY = newsLines.at(-1).y + CONFIG.font.news.size * CONFIG.font.lineHeight * 1.1;
                });
                console.log('新闻绘制完成，共', DATA.news.length, '条');

                // 8. 绘制微语
                const weiyuText = `【微语】${DATA.tip}`;
                // 重置微语绘制状态
                ctx.font = `${CONFIG.font.weiyu.weight || 'normal'} ${CONFIG.font.weiyu.size}px ${CONFIG.font.weiyu.family}`;
                ctx.fillStyle = CONFIG.font.weiyu.color;
                ctx.textAlign = 'left';
                
                const weiyuLines = wrapText(ctx, weiyuText, CONFIG.padding.left, currentY, newsMaxW, CONFIG.font.weiyu);
                weiyuLines.forEach(line => {
                    ctx.fillText(line.text, line.x, line.y);
                });
                console.log('微语绘制完成：', weiyuText);

                // 9. 裁剪画布
                const clipHeight = weiyuLines.at(-1).y + CONFIG.font.weiyu.size * CONFIG.font.lineHeight + CONFIG.clipExtra;
                const clipCanvas = document.createElement('canvas');
                clipCanvas.width = canvasW;
                clipCanvas.height = clipHeight;
                const clipCtx = clipCanvas.getContext('2d');
                drawWhiteBackground(clipCtx, canvasW, clipHeight);
                clipCtx.drawImage(canvas, 0, 0, canvasW, clipHeight, 0, 0, canvasW, clipHeight);

                // 10. 最终画布（修复Footer绘制错误）
                const finalCanvas = document.createElement('canvas');
                finalCanvas.width = canvasW;
                finalCanvas.height = clipHeight + footerImg.height;
                const finalCtx = finalCanvas.getContext('2d');
                drawWhiteBackground(finalCtx, canvasW, finalCanvas.height);
                
                // 绘制裁剪后的内容
                finalCtx.drawImage(clipCanvas, 0, 0);
                // 绘制Footer（修复：统一用finalCtx）
                finalCtx.drawImage(footerImg, 0, clipHeight);

                // 11. 生成Base64
                window.IMAGE_BASE64 = finalCanvas.toDataURL('image/png', 1.0);
                console.log('图片生成成功，Base64长度：', window.IMAGE_BASE64.length);

            } catch (err) {
                console.error('图片生成失败：', err);
                window.IMAGE_ERROR = err.message;
            }
        }
    </script>
</body>
</html>
